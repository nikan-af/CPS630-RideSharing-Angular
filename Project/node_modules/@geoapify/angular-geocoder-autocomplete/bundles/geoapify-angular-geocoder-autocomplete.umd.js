(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@geoapify/geocoder-autocomplete')) :
    typeof define === 'function' && define.amd ? define('@geoapify/angular-geocoder-autocomplete', ['exports', '@angular/core', '@geoapify/geocoder-autocomplete'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.geoapify = global.geoapify || {}, global.geoapify['angular-geocoder-autocomplete'] = {}), global.ng.core, global['@geoapify/geocoder-autocomplete']));
}(this, (function (exports, core, geocoderAutocomplete) { 'use strict';

    var GEOAPIFY_CONFIG = new core.InjectionToken('geoapify.config');

    var GeocoderAutocompleteComponent = /** @class */ (function () {
        function GeocoderAutocompleteComponent(config) {
            this.config = config;
            this.placeSelect = new core.EventEmitter();
            this.suggestionsChange = new core.EventEmitter();
        }
        GeocoderAutocompleteComponent.prototype.ngOnInit = function () {
        };
        GeocoderAutocompleteComponent.prototype.ngAfterViewInit = function () {
            var options = {};
            if (this.placeholder) {
                options.placeholder = this.placeholder;
            }
            if (this.type) {
                options.type = this.type;
            }
            if (this.lang) {
                options.lang = this.lang;
            }
            if (this.limit) {
                options.limit = this.limit;
            }
            if (this.skipIcons) {
                options.skipIcons = this.skipIcons;
            }
            if (this.skipDetails) {
                options.skipDetails = this.skipDetails;
            }
            this.autocomplete = new geocoderAutocomplete.GeocoderAutocomplete(this.container.nativeElement, this.config.apiKey, options);
            if (this.value) {
                this.autocomplete.setValue(this.value);
            }
            if (this.countryCodes) {
                console.warn("WARNING! Obsolete function called. The  'countryCodes' input has been deprecated, please use the new 'filterByCountryCode' input instead!");
                this.autocomplete.addFilterByCountry(this.countryCodes);
            }
            if (this.position) {
                console.warn("WARNING! Obsolete function called. The  'position' input has been deprecated, please use the new 'biasByLocation' input instead!");
                this.autocomplete.addBiasByProximity(this.position);
            }
            if (this.filterByCircle) {
                this.autocomplete.addFilterByCircle(this.filterByCircle);
            }
            if (this.filterByCountryCode) {
                this.autocomplete.addFilterByCountry(this.filterByCountryCode);
            }
            if (this.filterByRect) {
                this.autocomplete.addFilterByRect(this.filterByRect);
            }
            if (this.biasByCircle) {
                this.autocomplete.addBiasByCircle(this.biasByCircle);
            }
            if (this.biasByRect) {
                this.autocomplete.addBiasByRect(this.biasByRect);
            }
            if (this.biasByProximity) {
                this.autocomplete.addBiasByProximity(this.biasByProximity);
            }
            if (this.biasByCountryCode) {
                this.autocomplete.addBiasByCountry(this.biasByCountryCode);
            }
            this.autocomplete.on('select', this.onSelect.bind(this));
            this.autocomplete.on('suggestions', this.onSuggestions.bind(this));
        };
        GeocoderAutocompleteComponent.prototype.onSelect = function (value) {
            this.placeSelect.emit(value);
        };
        GeocoderAutocompleteComponent.prototype.onSuggestions = function (value) {
            this.suggestionsChange.emit(value);
        };
        GeocoderAutocompleteComponent.prototype.ngOnChanges = function (changes) {
            if (!this.autocomplete) {
                return;
            }
            if (changes['value'] &&
                !changes['value'].isFirstChange()) {
                this.autocomplete.setValue(changes['value'].currentValue);
            }
            if (changes['type'] &&
                !changes['type'].isFirstChange()) {
                this.autocomplete.setType(changes['type'].currentValue);
            }
            if (changes['lang'] &&
                !changes['lang'].isFirstChange()) {
                this.autocomplete.setLang(changes['lang'].currentValue);
            }
            if (changes['filterByCircle'] &&
                !changes['filterByCircle'].isFirstChange()) {
                this.autocomplete.addFilterByCircle(changes['filterByCircle'].currentValue);
            }
            if (changes['filterByCountryCode'] &&
                !changes['filterByCountryCode'].isFirstChange()) {
                this.autocomplete.addFilterByCountry(changes['filterByCountryCode'].currentValue);
            }
            if (changes['filterByRect'] &&
                !changes['filterByRect'].isFirstChange()) {
                this.autocomplete.addFilterByRect(changes['filterByRect'].currentValue);
            }
            if (changes['biasByCircle'] &&
                !changes['biasByCircle'].isFirstChange()) {
                this.autocomplete.addBiasByCircle(changes['biasByCircle'].currentValue);
            }
            if (changes['biasByRect'] &&
                !changes['biasByRect'].isFirstChange()) {
                this.autocomplete.addBiasByRect(changes['biasByRect'].currentValue);
            }
            if (changes['biasByProximity'] &&
                !changes['biasByProximity'].isFirstChange()) {
                this.autocomplete.addBiasByProximity(changes['biasByProximity'].currentValue);
            }
            if (changes['biasByCountryCode'] &&
                !changes['biasByCountryCode'].isFirstChange()) {
                this.autocomplete.addBiasByCountry(changes['biasByCountryCode'].currentValue);
            }
            if (changes['countryCodes'] &&
                !changes['countryCodes'].isFirstChange()) {
                console.warn("WARNING! Obsolete function called. The  'countryCodes' input has been deprecated, please use the new 'filterByCountryCode' input instead!");
                this.autocomplete.addFilterByCountry(changes['countryCodes'].currentValue);
            }
            if (changes['position'] &&
                !changes['position'].isFirstChange()) {
                console.warn("WARNING! Obsolete function called. The  'position' input has been deprecated, please use the new 'biasByLocation' input instead!");
                this.autocomplete.addBiasByProximity(changes['position'].currentValue);
            }
            if (changes['limit'] &&
                !changes['limit'].isFirstChange()) {
                this.autocomplete.setLimit(changes['limit'].currentValue);
            }
        };
        GeocoderAutocompleteComponent.prototype.ngOnDestroy = function () {
            this.autocomplete.off('select', this.onSelect);
            this.autocomplete.off('suggestions', this.onSuggestions);
        };
        return GeocoderAutocompleteComponent;
    }());
    GeocoderAutocompleteComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'geoapify-geocoder-autocomplete',
                    template: '<div class="geocoder-container" #container></div>',
                    styles: ['.geocoder-container {position: relative}']
                },] }
    ];
    GeocoderAutocompleteComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [GEOAPIFY_CONFIG,] }] }
    ]; };
    GeocoderAutocompleteComponent.propDecorators = {
        container: [{ type: core.ViewChild, args: ['container',] }],
        value: [{ type: core.Input }],
        placeholder: [{ type: core.Input }],
        type: [{ type: core.Input }],
        skipIcons: [{ type: core.Input }],
        skipDetails: [{ type: core.Input }],
        lang: [{ type: core.Input }],
        filterByCountryCode: [{ type: core.Input }],
        filterByCircle: [{ type: core.Input }],
        filterByRect: [{ type: core.Input }],
        biasByCountryCode: [{ type: core.Input }],
        biasByCircle: [{ type: core.Input }],
        biasByRect: [{ type: core.Input }],
        biasByProximity: [{ type: core.Input }],
        countryCodes: [{ type: core.Input }],
        position: [{ type: core.Input }],
        limit: [{ type: core.Input }],
        placeSelect: [{ type: core.Output }],
        suggestionsChange: [{ type: core.Output }]
    };

    var GeoapifyGeocoderAutocompleteModule = /** @class */ (function () {
        function GeoapifyGeocoderAutocompleteModule() {
        }
        GeoapifyGeocoderAutocompleteModule.withConfig = function (apiKey) {
            return {
                ngModule: GeoapifyGeocoderAutocompleteModule,
                providers: [
                    { provide: GEOAPIFY_CONFIG, useValue: { apiKey: apiKey } }
                ]
            };
        };
        return GeoapifyGeocoderAutocompleteModule;
    }());
    GeoapifyGeocoderAutocompleteModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [GeocoderAutocompleteComponent],
                    imports: [],
                    exports: [GeocoderAutocompleteComponent]
                },] }
    ];

    /*
     * Public API Surface of angular-geocoder-autocomplete
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.GeoapifyGeocoderAutocompleteModule = GeoapifyGeocoderAutocompleteModule;
    exports.GeocoderAutocompleteComponent = GeocoderAutocompleteComponent;
    exports.Éµa = GEOAPIFY_CONFIG;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=geoapify-angular-geocoder-autocomplete.umd.js.map

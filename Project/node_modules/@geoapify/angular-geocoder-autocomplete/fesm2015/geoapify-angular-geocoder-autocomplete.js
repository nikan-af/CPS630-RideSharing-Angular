import { InjectionToken, EventEmitter, Component, Inject, ViewChild, Input, Output, NgModule } from '@angular/core';
import { GeocoderAutocomplete } from '@geoapify/geocoder-autocomplete';

const GEOAPIFY_CONFIG = new InjectionToken('geoapify.config');

class GeocoderAutocompleteComponent {
    constructor(config) {
        this.config = config;
        this.placeSelect = new EventEmitter();
        this.suggestionsChange = new EventEmitter();
    }
    ngOnInit() {
    }
    ngAfterViewInit() {
        const options = {};
        if (this.placeholder) {
            options.placeholder = this.placeholder;
        }
        if (this.type) {
            options.type = this.type;
        }
        if (this.lang) {
            options.lang = this.lang;
        }
        if (this.limit) {
            options.limit = this.limit;
        }
        if (this.skipIcons) {
            options.skipIcons = this.skipIcons;
        }
        if (this.skipDetails) {
            options.skipDetails = this.skipDetails;
        }
        this.autocomplete = new GeocoderAutocomplete(this.container.nativeElement, this.config.apiKey, options);
        if (this.value) {
            this.autocomplete.setValue(this.value);
        }
        if (this.countryCodes) {
            console.warn("WARNING! Obsolete function called. The  'countryCodes' input has been deprecated, please use the new 'filterByCountryCode' input instead!");
            this.autocomplete.addFilterByCountry(this.countryCodes);
        }
        if (this.position) {
            console.warn("WARNING! Obsolete function called. The  'position' input has been deprecated, please use the new 'biasByLocation' input instead!");
            this.autocomplete.addBiasByProximity(this.position);
        }
        if (this.filterByCircle) {
            this.autocomplete.addFilterByCircle(this.filterByCircle);
        }
        if (this.filterByCountryCode) {
            this.autocomplete.addFilterByCountry(this.filterByCountryCode);
        }
        if (this.filterByRect) {
            this.autocomplete.addFilterByRect(this.filterByRect);
        }
        if (this.biasByCircle) {
            this.autocomplete.addBiasByCircle(this.biasByCircle);
        }
        if (this.biasByRect) {
            this.autocomplete.addBiasByRect(this.biasByRect);
        }
        if (this.biasByProximity) {
            this.autocomplete.addBiasByProximity(this.biasByProximity);
        }
        if (this.biasByCountryCode) {
            this.autocomplete.addBiasByCountry(this.biasByCountryCode);
        }
        this.autocomplete.on('select', this.onSelect.bind(this));
        this.autocomplete.on('suggestions', this.onSuggestions.bind(this));
    }
    onSelect(value) {
        this.placeSelect.emit(value);
    }
    onSuggestions(value) {
        this.suggestionsChange.emit(value);
    }
    ngOnChanges(changes) {
        if (!this.autocomplete) {
            return;
        }
        if (changes['value'] &&
            !changes['value'].isFirstChange()) {
            this.autocomplete.setValue(changes['value'].currentValue);
        }
        if (changes['type'] &&
            !changes['type'].isFirstChange()) {
            this.autocomplete.setType(changes['type'].currentValue);
        }
        if (changes['lang'] &&
            !changes['lang'].isFirstChange()) {
            this.autocomplete.setLang(changes['lang'].currentValue);
        }
        if (changes['filterByCircle'] &&
            !changes['filterByCircle'].isFirstChange()) {
            this.autocomplete.addFilterByCircle(changes['filterByCircle'].currentValue);
        }
        if (changes['filterByCountryCode'] &&
            !changes['filterByCountryCode'].isFirstChange()) {
            this.autocomplete.addFilterByCountry(changes['filterByCountryCode'].currentValue);
        }
        if (changes['filterByRect'] &&
            !changes['filterByRect'].isFirstChange()) {
            this.autocomplete.addFilterByRect(changes['filterByRect'].currentValue);
        }
        if (changes['biasByCircle'] &&
            !changes['biasByCircle'].isFirstChange()) {
            this.autocomplete.addBiasByCircle(changes['biasByCircle'].currentValue);
        }
        if (changes['biasByRect'] &&
            !changes['biasByRect'].isFirstChange()) {
            this.autocomplete.addBiasByRect(changes['biasByRect'].currentValue);
        }
        if (changes['biasByProximity'] &&
            !changes['biasByProximity'].isFirstChange()) {
            this.autocomplete.addBiasByProximity(changes['biasByProximity'].currentValue);
        }
        if (changes['biasByCountryCode'] &&
            !changes['biasByCountryCode'].isFirstChange()) {
            this.autocomplete.addBiasByCountry(changes['biasByCountryCode'].currentValue);
        }
        if (changes['countryCodes'] &&
            !changes['countryCodes'].isFirstChange()) {
            console.warn("WARNING! Obsolete function called. The  'countryCodes' input has been deprecated, please use the new 'filterByCountryCode' input instead!");
            this.autocomplete.addFilterByCountry(changes['countryCodes'].currentValue);
        }
        if (changes['position'] &&
            !changes['position'].isFirstChange()) {
            console.warn("WARNING! Obsolete function called. The  'position' input has been deprecated, please use the new 'biasByLocation' input instead!");
            this.autocomplete.addBiasByProximity(changes['position'].currentValue);
        }
        if (changes['limit'] &&
            !changes['limit'].isFirstChange()) {
            this.autocomplete.setLimit(changes['limit'].currentValue);
        }
    }
    ngOnDestroy() {
        this.autocomplete.off('select', this.onSelect);
        this.autocomplete.off('suggestions', this.onSuggestions);
    }
}
GeocoderAutocompleteComponent.decorators = [
    { type: Component, args: [{
                selector: 'geoapify-geocoder-autocomplete',
                template: '<div class="geocoder-container" #container></div>',
                styles: ['.geocoder-container {position: relative}']
            },] }
];
GeocoderAutocompleteComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [GEOAPIFY_CONFIG,] }] }
];
GeocoderAutocompleteComponent.propDecorators = {
    container: [{ type: ViewChild, args: ['container',] }],
    value: [{ type: Input }],
    placeholder: [{ type: Input }],
    type: [{ type: Input }],
    skipIcons: [{ type: Input }],
    skipDetails: [{ type: Input }],
    lang: [{ type: Input }],
    filterByCountryCode: [{ type: Input }],
    filterByCircle: [{ type: Input }],
    filterByRect: [{ type: Input }],
    biasByCountryCode: [{ type: Input }],
    biasByCircle: [{ type: Input }],
    biasByRect: [{ type: Input }],
    biasByProximity: [{ type: Input }],
    countryCodes: [{ type: Input }],
    position: [{ type: Input }],
    limit: [{ type: Input }],
    placeSelect: [{ type: Output }],
    suggestionsChange: [{ type: Output }]
};

class GeoapifyGeocoderAutocompleteModule {
    static withConfig(apiKey) {
        return {
            ngModule: GeoapifyGeocoderAutocompleteModule,
            providers: [
                { provide: GEOAPIFY_CONFIG, useValue: { apiKey: apiKey } }
            ]
        };
    }
}
GeoapifyGeocoderAutocompleteModule.decorators = [
    { type: NgModule, args: [{
                declarations: [GeocoderAutocompleteComponent],
                imports: [],
                exports: [GeocoderAutocompleteComponent]
            },] }
];

/*
 * Public API Surface of angular-geocoder-autocomplete
 */

/**
 * Generated bundle index. Do not edit.
 */

export { GeoapifyGeocoderAutocompleteModule, GeocoderAutocompleteComponent, GEOAPIFY_CONFIG as Éµa };
//# sourceMappingURL=geoapify-angular-geocoder-autocomplete.js.map
